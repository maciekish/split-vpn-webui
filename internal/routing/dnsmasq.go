package routing

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

const dnsmasqConfigFileName = "split-vpn-webui.conf"

// DnsmasqManager writes dnsmasq ipset config and reloads dnsmasq.
type DnsmasqManager struct {
	exec       Executor
	configPath string
}

func NewDnsmasqManager(exec Executor) (*DnsmasqManager, error) {
	if exec == nil {
		exec = osExec{}
	}
	dir, err := DetectDnsmasqConfDir()
	if err != nil {
		return nil, err
	}
	return &DnsmasqManager{
		exec:       exec,
		configPath: filepath.Join(dir, dnsmasqConfigFileName),
	}, nil
}

func NewDnsmasqManagerWithPath(configPath string, exec Executor) *DnsmasqManager {
	if exec == nil {
		exec = osExec{}
	}
	return &DnsmasqManager{exec: exec, configPath: configPath}
}

func (m *DnsmasqManager) ConfigPath() string {
	return m.configPath
}

// DetectDnsmasqConfDir finds or creates a dnsmasq conf.d directory.
func DetectDnsmasqConfDir() (string, error) {
	return detectDnsmasqConfDir([]string{"/run/dnsmasq.d", "/run/dnsmasq.dhcp.conf.d"})
}

func detectDnsmasqConfDir(candidates []string) (string, error) {
	for _, candidate := range candidates {
		info, err := os.Stat(candidate)
		if err == nil && info.IsDir() {
			return candidate, nil
		}
	}
	primary := candidates[0]
	if err := os.MkdirAll(primary, 0o755); err != nil {
		return "", err
	}
	return primary, nil
}

// GenerateDnsmasqConf renders config lines for all group domains.
func (m *DnsmasqManager) GenerateDnsmasqConf(groups []DomainGroup) string {
	lines := []string{
		"# Generated by split-vpn-webui. Do not edit.",
	}
	seenLines := map[string]struct{}{}

	sortedGroups := make([]DomainGroup, len(groups))
	copy(sortedGroups, groups)
	sort.Slice(sortedGroups, func(i, j int) bool { return sortedGroups[i].Name < sortedGroups[j].Name })
	for _, group := range sortedGroups {
		if len(group.Rules) == 0 {
			v4Set, v6Set := GroupSetNames(group.Name)
			for _, domain := range group.Domains {
				line := dnsmasqLine(domain, v4Set, v6Set)
				if line == "" {
					continue
				}
				if _, exists := seenLines[line]; exists {
					continue
				}
				seenLines[line] = struct{}{}
				lines = append(lines, line)
			}
			continue
		}
		for idx, rule := range group.Rules {
			sets := RuleSetNames(group.Name, idx)
			domains := append([]string(nil), rule.Domains...)
			domains = append(domains, rule.WildcardDomains...)
			sort.Strings(domains)
			for _, domain := range domains {
				line := dnsmasqLine(domain, sets.DestinationV4, sets.DestinationV6)
				if line == "" {
					continue
				}
				if _, exists := seenLines[line]; exists {
					continue
				}
				seenLines[line] = struct{}{}
				lines = append(lines, line)
			}
		}
	}
	return strings.Join(lines, "\n") + "\n"
}

func dnsmasqLine(domain, v4Set, v6Set string) string {
	trimmed := strings.TrimSpace(strings.TrimPrefix(strings.ToLower(domain), "*."))
	if trimmed == "" {
		return ""
	}
	return fmt.Sprintf("ipset=/%s/%s,%s", trimmed, v4Set, v6Set)
}

// WriteDnsmasqConf writes config atomically.
func (m *DnsmasqManager) WriteDnsmasqConf(content string) error {
	if strings.TrimSpace(m.configPath) == "" {
		return fmt.Errorf("dnsmasq config path is required")
	}
	if err := os.MkdirAll(filepath.Dir(m.configPath), 0o755); err != nil {
		return err
	}
	tmpPath := m.configPath + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0o644); err != nil {
		return err
	}
	if err := os.Chmod(tmpPath, 0o644); err != nil {
		_ = os.Remove(tmpPath)
		return err
	}
	if err := os.Rename(tmpPath, m.configPath); err != nil {
		_ = os.Remove(tmpPath)
		return err
	}
	return nil
}

// ReloadDnsmasq applies config updates with minimal interruption.
func (m *DnsmasqManager) ReloadDnsmasq() error {
	var hupErr error
	pidBytes, pidErr := m.exec.Output("pidof", "dnsmasq")
	if pidErr == nil {
		fields := strings.Fields(strings.TrimSpace(string(pidBytes)))
		if len(fields) > 0 && isDigits(fields[0]) {
			if err := m.exec.Run("kill", "-HUP", fields[0]); err == nil {
				return nil
			} else {
				hupErr = err
			}
		}
	}
	reloadErr := m.exec.Run("systemctl", "reload", "dnsmasq")
	if reloadErr == nil {
		return nil
	}
	restartErr := m.exec.Run("systemctl", "restart", "dnsmasq")
	if restartErr != nil {
		if hupErr != nil {
			return fmt.Errorf("dnsmasq reload failed (kill -HUP: %v, systemctl reload: %v, systemctl restart: %w)", hupErr, reloadErr, restartErr)
		}
		return fmt.Errorf("dnsmasq reload failed (systemctl reload: %v, systemctl restart: %w)", reloadErr, restartErr)
	}
	return nil
}

func isDigits(value string) bool {
	if value == "" {
		return false
	}
	for _, r := range value {
		if !unicode.IsDigit(r) {
			return false
		}
	}
	return true
}
